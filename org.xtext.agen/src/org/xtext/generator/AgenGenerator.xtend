/*
 * generated by Xtext 2.24.0
 */
package org.xtext.generator

import java.util.HashMap
import java.util.Iterator
import java.util.Map.Entry
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.agen.AlterPacketFault
import org.xtext.agen.BigPacketFault
import org.xtext.agen.RepeatExecution
import org.xtext.agen.CodeBlock
import org.xtext.agen.Condition
import org.xtext.agen.ExecParams
import org.xtext.agen.Exit
import org.xtext.agen.Fault
import org.xtext.agen.FaultCond
import org.xtext.agen.LeakFault
import org.xtext.agen.Log
import org.xtext.agen.Node
import org.xtext.agen.Random
import org.xtext.agen.RunConfiguration
import org.xtext.agen.Sleep
import org.xtext.agen.Syncpoint
import org.xtext.agen.What
import org.xtext.agen.When
import org.xtext.agen.Where
import java.util.ArrayList
import org.xtext.agen.CPULoader

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AgenGenerator extends AbstractGenerator {

	HashMap<String, CodeBlock> codeBlocksMap = newHashMap();
	HashMap<String, Condition> condsMap = newHashMap();
	HashMap<String, FaultCond> faultCondsMap = newHashMap();
	HashMap<String, Syncpoint> syncpointsMap = newHashMap();
	HashMap<String, ExecParams> execParamsMap = newHashMap();
	HashMap<String, String> faultsCompiled = newHashMap();
	//firstvalue is the header second is the compiled faultCond
	HashMap<String, Pair<String,String>> logsCompiled = newHashMap();
	HashMap<String, Log> logsMap = newHashMap();
	//a fault e a lista de syncpoints que depende
	HashMap<String, ArrayList<String>> syncpointsInitialRequest = newHashMap();
	HashMap<String, ArrayList<String>> faultCondPerFault = newHashMap();
	HashMap<String, ArrayList<String>> importsPerFault = newHashMap();
	HashMap<String, ArrayList<String>> condsPerFault = newHashMap();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		clearLists()
		getLists(resource)
		compileFaults(resource)
		for(runConfig : resource.allContents.toIterable.filter(RunConfiguration)){
			runConfig.compile(fsa)
			//the object types extends EObject so i have access to its methods
		}
		fsa.generateFile(
			"PreMadeFaults.java", preMadeFaults
		)
	}
	
	def compile(RunConfiguration runConfig, IFileSystemAccess2 fsa){
		for (node : runConfig.nodes){
			fsa.generateFile(
				node.name + 'gen.java', node.compile(runConfig.runtimePackage, runConfig.coordinatorLocation)
			)
		}
	}
	
	def compile(Node node, String runtimePackage, String coordinatorLocation) {
		if(node.faultIDs.get(0) == 'none'){
			var nodeConditions = newArrayList
			return
			'''
			«makeHeader(runtimePackage, newArrayList, coordinatorLocation, node.nodeLocation, node.name, false, newArrayList, newArrayList)»
			«makeLogHeader(node.logLocations, node.name)»
			«proteusRuntimeJunction(node.firstAttachPoint)»
			«makeLogConditions(node.logLocations, nodeConditions)»
			«makeCondFuncs(node.name, nodeConditions)»
			}
			'''
		} else {
			var nodeSyncpointsInitialRequestDepend = newArrayList
			var nodeSyncpointsInitialRequestTrigger = newArrayList
			var nodeFaultConditions = newArrayList
			var nodeExtraImports = newArrayList
			var nodeConditions = newArrayList
			importsPerFault.put(node.name, newArrayList)
			var ret =
			'''
			«makeLogHeader(node.logLocations, node.name)»
			«proteusRuntimeJunction(node.firstAttachPoint)»
			
			«IF node.faultIDs.get(0) == 'all'»
				«FOR faults : faultsCompiled.entrySet SEPARATOR '\n'»
					«faults.value»
					«var discard = nodeSyncpointsInitialRequestDepend.addAll(syncpointsInitialRequest.get(faults.key))»
					«var discard2 = nodeFaultConditions.addAll(faultCondPerFault.get(faults.key))»
					«var discard3 = nodeExtraImports.addAll(importsPerFault.get(faults.key))»
					«var discard4 = nodeConditions.addAll(condsPerFault.get(faults.key))»
				«ENDFOR»
			«ELSE»
				«FOR faultID : node.faultIDs»
					«faultsCompiled.get(faultID)»
					«var discard = nodeSyncpointsInitialRequestDepend.addAll(syncpointsInitialRequest.get(faultID))»
					«var discard2 = nodeFaultConditions.addAll(faultCondPerFault.get(faultID))»
					«var discard3 = nodeExtraImports.addAll(importsPerFault.get(faultID))»
					«var discard4 = nodeConditions.addAll(condsPerFault.get(faultID))»
				«ENDFOR»
			«ENDIF»
			«makeSyncpointsFaultCond(node.name, nodeSyncpointsInitialRequestTrigger, nodeFaultConditions)»
			«makeFaultCond(nodeFaultConditions, nodeConditions)»
			«makeLogConditions(node.logLocations, nodeConditions)»
			«makeCondFuncs(node.name, nodeConditions)»
			}
			'''
			ret = makeHeader(runtimePackage, nodeExtraImports, coordinatorLocation, node.nodeLocation, node.name, true, nodeSyncpointsInitialRequestDepend, nodeSyncpointsInitialRequestTrigger) + ret
			return ret
		}
	}
		
	def makeFaultCond(ArrayList<String> nodeFaultConditions, ArrayList<String> nodeConditions) {
		var ret = ""
		for (faultCondName : nodeFaultConditions) {
			ret += faultCondsMap.get(faultCondName).compile("")
			nodeConditions.addAll(condsPerFault.get(faultCondName))
		}
		return ret
	}
		
	def String makeSyncpointsFaultCond(String nodeName, ArrayList<String> nodeSyncpointsInitialRequestTrigger, ArrayList<String> nodeFaultConditions) {
		//add the faultConds necessary for this nodes syncpoints
		var ret = ''
		for (syncs : syncpointsMap.values){
			for ( syncsDependants : syncs.nodesDependant ){
				if (syncsDependants.equals(nodeName)) {
					nodeFaultConditions.add(syncs.faultCond.name)
					nodeSyncpointsInitialRequestTrigger.add(syncs.name)
				}
			}
		}
		return ret
	}
		
	def String makeLogConditions(EList<String> logList, ArrayList<String> nodeConditions) {
		var ret=''
		for (logName : logList){
			if (logName === null) return ret
			else {
				var log = logsMap.get(logName)
				//log.faultCond.extraData = combineCodeBoxes(log.faultCond.extraData, log.extraData)
				var stateBased = ""
				var extraData = ""
				if (log.stateBased!==null) {
					stateBased = log.stateBased.compile(logName)
				}
				if (log.extraData!==null) {
					extraData = log.extraData.compile(logName)
				}
				var logFaultCond = faultCondsMap.get(log.faultCond);
				ret = ret.concat(logFaultCond.compile(extraData))
				nodeConditions.addAll(condsPerFault.get(logName))
			}
		}
		return ret
	}
		
	def String makeLogHeader(EList<String> list, String nodeName) {
		var ret=''
		for (logName : list){
			if (logName === null) return ret
			else {
				if(logsMap.get(logName).stateBased !== null){
				var vals = logsMap.get(logName).stateBased.compile(nodeName)
				ret.concat(vals)
				}
			}
		}
		return ret
	}
	
	def compileFaults(Resource resource) {
		//iterate over the faultConds to add them after the fault
		for(fault : resource.allContents.toIterable.filter(Fault)){
			syncpointsInitialRequest.put(fault.name, newArrayList)
			faultCondPerFault.put(fault.name, newArrayList)
			condsPerFault.put(fault.name, newArrayList)
			importsPerFault.put(fault.name, newArrayList)
			var result=''
			result += fault.compile + '\n'
			faultsCompiled.put(fault.name, result)
		}
	}

		private def compile(Fault fault)
		'''
		«FOR ExecParams exec : fault.execParams»
			«IF exec.when !== null && exec.when.betweenRounds !== null»
				int «exec.getName»counter = 0;
			«ENDIF»
		«ENDFOR»
		@Around("«fault.pointcut»")
		public Object «fault.name»(ProceedingJoinPoint joinpoint){
			Object retobj = null;
			String randomLogData = "";
			long startTimestamp = System.currentTimeMillis();
			Object[] args = joinpoint.getArgs();
			«execCompileConditions(fault.execParams, 'Before', fault.name)»
			try {
				retobj = joinpoint.proceed(args);
			} catch (Throwable e) {
				e.printStackTrace();
				System.exit(0);
			}
			«execCompileConditions(fault.execParams, 'After', fault.name)»
			ProteusRuntime.sendLogs(curNodeName, "«fault.name»", startTimestamp, randomLogData);
			return retobj;
		}
		'''
		
	def String execCompileConditions(EList <ExecParams> execParamsList, String BeforeAfter, String faultName) {
		var result = ''
		for (ExecParams exec : execParamsList){
			var realExecParams = execParamsMap.get(exec.getName)
			if (realExecParams.where.literal == BeforeAfter)
				result += realExecParams.compile(faultName)
		}
		return result
	}
		
	private def compile (ExecParams exec, String faultName)
	'''
	«IF exec.when !== null»
		«exec.when.compile(exec.what.compile(faultName).toString, exec.getName, faultName)»
	«ELSE»
		ProteusRuntime.addLogExecInfo("«exec.getName»", "Always", "");
		«exec.what.compile(faultName)»
	«ENDIF»
	'''

	private def compile (When when, String whatToExecute, String execParamsName, String faultName)
	'''
	«IF when.betweenRounds !== null»
		«makeBetweenIf(when.betweenRounds.start, when.betweenRounds.end, when.betweenRounds.interval , execParamsName + "counter")»
		«IF when.betweenRounds.random !== null»
			«when.betweenRounds.random.compile»
			ProteusRuntime.addLogExecInfo("«execParamsName»", "Round", String.valueOf(«execParamsName»counter));
			«whatToExecute» }}
		«ELSE»
			ProteusRuntime.addLogExecInfo("«execParamsName»", "Round", String.valueOf(«execParamsName»counter));
			«whatToExecute» }
		«ENDIF»
		«IF when.betweenRounds.condition!==null»
			if( «when.betweenRounds.condition.name»(retobj, joinpoint))
				«execParamsName»counter++;
		«ELSE»
			«execParamsName»counter++;
		«ENDIF»
	«ELSEIF when.ifCondition !== null»
		«var discard = condsPerFault.get(faultName).add(when.ifCondition.getName)»
		if(«when.ifCondition.getName»(retobj, joinpoint)){
		ProteusRuntime.addLogExecInfo("«execParamsName»", "Custom", "true");
		«whatToExecute» }
	«ELSEIF when.random !== null»
		«when.random.compile»
		ProteusRuntime.addLogExecInfo("«execParamsName»", "Random", "true");
		«whatToExecute» }
	«ELSEIF when.faultCond !== null»
		«var discard = faultCondPerFault.get(faultName).add(when.faultCond.name)»
		ProteusRuntime.addLogExecInfo("«execParamsName»", "FaultCond", "true");
		«makeFaultCondIf(when.faultCond, whatToExecute)»
	«ELSEIF when.syncpoint!==null»
		«var syncpointOnFail = syncpointsMap.get(when.syncpoint).onFail.literal»
		«var discard = syncpointsInitialRequest.get(faultName).add(when.syncpoint)»
		«IF syncpointOnFail.equals('continue')»
			if(ProteusRuntime.askSyncpointStatus(curNodeName, "«when.syncpoint»")){
				ProteusRuntime.addLogExecInfo("«execParamsName»", "Sync", "true");
				«whatToExecute»
			}
		«ELSEIF syncpointOnFail.equals('retry')»
			while(!ProteusRuntime.askSyncpointStatus(curNodeName, "«when.syncpoint»")){
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
					System.exit(0);
				}
				ProteusRuntime.addLogExecInfo("«execParamsName»", "Sync", "«when.syncpoint»");
				«whatToExecute»
			}
		«ENDIF»
	«ENDIF»
	'''

	def compile (Random random)
	'''
	Integer randVal = randomGen.nextInt(100);
	if(randVal<«random.chance») {
	'''

	def String makeBetweenIf(int start, int end, int interval, String varname) {
		var String result = 'if('
		if(start != 0){
			result += varname + ' >= ' + start + ' && '
		}
		if(end != 0){
			result += varname + ' <= ' + end + ' && '
		}
		if(interval==0){
			return result + 'true){'
		}
		result += varname + ' % ' + interval + ' == 0){'
		return result;
	}

	def String makeFaultCondIf(FaultCond fcond, String whatToExecute) {
		var realfcond = fcond;
		//if its just a reference get the fully detailed one
		if (realfcond.where === null){
			realfcond = faultCondsMap.get(realfcond.name)
		}
		if (realfcond.when.betweenRounds !== null && realfcond.when.betweenRounds.interval != 0){
			return 'if( ' + realfcond.getName + '){\n' + whatToExecute + '}'
		}
		if (realfcond.when.betweenSeconds !== null){
			return 'if( ' + realfcond.getName + '){\n' + whatToExecute + '}'
		}
		return 'if( ' + realfcond.getName + '){\n' + whatToExecute + '\n' + realfcond.getName + '= false;}'
	}

	private def compile(FaultCond fcond, String additionalLogData){
		//in case the fcond is just a name get the real one
		var realfcond = faultCondsMap.get(fcond.name)
		var whatToExecute = combineCodeBoxWithStrings(realfcond.extraData, realfcond.name + ' = true;', additionalLogData, fcond.name)
		var ret = 
		'''
		
		Boolean «realfcond.name» = false;
		«IF realfcond.when !== null && realfcond.when.betweenRounds !== null»
			int «realfcond.name»counter = 0;
		«ENDIF»
		«realfcond.where.compile(realfcond.name)»
			String randomLogData = "";
			long startTimestamp = System.currentTimeMillis();
			«realfcond.name» = false;
			«IF realfcond.when !== null»
			«realfcond.when.compile(whatToExecute, realfcond.name, realfcond.name)»
			«ENDIF»
			ProteusRuntime.sendLogs(curNodeName, "«fcond.name»", startTimestamp, randomLogData);
		}

		'''
	return ret
	}

	def compile(Where where, String name) {
		//if its not equal to before than its after returning
		'''
		«IF where.joinType.literal == "Before"»
		@Before(«where.getName»)
		public void «where.joinType.literal»«name»(JoinPoint joinpoint) {
			Object retobj = null;
			Object[] args = joinpoint.getArgs();
		«ELSE»
		@AfterReturning( pointcut = "«where.getName»", returning = "retobj")
		public void «where.joinType.literal»«name»(JoinPoint joinpoint, Object retobj) {
			Object[] args = joinpoint.getArgs();
		«ENDIF»
	'''
	}

	def String makeCondFuncs(String nodeName, ArrayList<String> nodeConditions){

		var result = ''
		var condsNames = nodeConditions.iterator()
		//var Iterator<Entry<String, Condition>> condsIt = condsMap.entrySet().iterator();
		while (condsNames.hasNext()){
			var condsName = condsNames.next();
			var condition = condsMap.get(condsName)
			result += '''
			private Boolean «condition.name» (Object retobj, JoinPoint joinpoint){
				«condition.compile(nodeName)»
			}
			'''
		}
		result
	}

	private def compile(What what, String faultName)
	'''
	«IF what.codeBlock !== null»
		«what.codeBlock.compile(faultName)»
	«ELSEIF what.sleep !== null»
		«what.sleep.compile»
	«ELSEIF what.exit !== null»
		«what.exit.compile(faultName)»
	«ELSEIF what.cpuLoader !== null»
		«what.cpuLoader.compile»
	«ELSEIF what.bigPacketFault !== null»
		«what.bigPacketFault.compile»
	«ELSEIF what.leakFault !== null»
		«what.leakFault.compile»
	«ELSEIF what.alterPacketFault !== null»
		«what.alterPacketFault.compile»
	«ELSEIF what.skipExecution !== null»
		«skipExecutionCompile(faultName)»
	«ELSEIF what.repeatExecution !== null»
		«what.repeatExecution.compile»
	«ENDIF»
	'''
	
	private def compile(RepeatExecution repeatExecution)
	'''
		for(int i=0;i<«repeatExecution.times»;i++){
			try {
				joinpoint.proceed(args);
			} catch (Throwable e) {
				e.printStackTrace();
				System.exit(0);
			}
		}
	'''
		
	def skipExecutionCompile(String faultName) {
		'''
		ProteusRuntime.sendLogs(curNodeName, "«faultName»", startTimestamp, randomLogData);
		return;
		'''
	}
	
	private def compile(Sleep sleep)
	'''
		try {
			Thread.sleep(«sleep.time»);
		} catch (InterruptedException e) {
			e.printStackTrace();
			System.exit(0);
		}
	'''

	private def compile(Exit exit, String faultName)
	'''
		ProteusRuntime.sendLogs(curNodeName, "«faultName»", startTimestamp, randomLogData);
		System.exit(«exit.type»);
	'''
	
	private def compile(CPULoader cpuLoader)
	'''
		Thread threadLoad = new PreMadeFaults.ThreadLoad();
		for(int i=0; i<«cpuLoader.amount»; i++){
			threadLoad.start();
			threadLoad = new PreMadeFaults.ThreadLoad();
		}
	'''

	private def compile(BigPacketFault bpf)
	'''
		PreMadeFaults.bigPacketFault(args[«bpf.originalData»], «bpf.timesLarger»);
	'''

	private def compile(LeakFault lf)
	'''
		PreMadeFaults.leakFault(«lf.nrofLeaks»);
	'''

	private def compile(AlterPacketFault apf)
	'''
		PreMadeFaults.alterPacketFault(args[«apf.originalData»], «apf.kindOfAlteration.literal»);
	'''

	private def compile(CodeBlock cb, String faultName){
		var realcb = codeBlocksMap.get(cb.getName);
		if (realcb.imports != null) {
			importsPerFault.get(faultName).add(realcb.imports)
		}
		return realcb.code
	}
	
	private def compile(Condition cd, String faultName){
		if (cd.imports != null) {
			importsPerFault.get(faultName).add(cd.imports)
		}
		return cd.code
	}
		
	def CodeBlock combineCodeBoxes(CodeBlock first, CodeBlock second, String faultName){
		if (first===null) {
			return second
		} else if(second === null){
			return first
		} else {
		//puts the second into the first one and returns it
		var firstCodeBlock = first.compile(faultName).toString()
		var secondCodeBlock = second.compile(faultName).toString()
		first.code = firstCodeBlock.concat(secondCodeBlock)
		first.name = null
		return first
		}
	}
	
	def String combineCodeBoxWithStrings(CodeBlock block, String string1, String string2, String faultName) {
		var string = string1 + string2
		if (block === null){
			return string
		} else {
			return block.compile(faultName).toString() + string
		}
	}
	
	//returns the hashmaps for the CodeBlocks, Conditions and FaultConditions
	//populates the name field when needed
	def getLists(Resource resource) {
		var counter=0
		
		for(block : resource.allContents.toIterable.filter(CodeBlock)){
			if (block.getName === null){
				block.setName("codeBlock"+counter);
				counter ++;
			}
			codeBlocksMap.put(block.getName, block);
		}
		
        counter=0
		for(condition : resource.allContents.toIterable.filter(Condition)){
			if (condition.getName === null){
				condition.setName("cond"+counter)
				counter++
			}
			condsMap.put(condition.getName, condition);
		}

		counter = 0
		for(faultCondition : resource.allContents.toIterable.filter(FaultCond)){
			//if its not just a reference to a faultcondition add it to the hashmap
			if (faultCondition.where !== null){
				if (faultCondition.getName === null){
					faultCondition.setName('fCond' + counter)
					counter++
				}
				condsPerFault.put(faultCondition.getName, newArrayList)
				importsPerFault.put(faultCondition.getName, newArrayList)
				faultCondsMap.put(faultCondition.getName, faultCondition);
			}
		}
		
		counter = 0
		for(exec : resource.allContents.toIterable.filter(ExecParams)){
			if (exec.getName === null){
				exec.setName('execParam'+counter)
				counter++
			}
			execParamsMap.put(exec.getName, exec);
		}
		
		for(syncs : resource.allContents.toIterable.filter(Syncpoint)){
			syncpointsMap.put(syncs.name, syncs)
		}
		
		for(log : resource.allContents.toIterable.filter(Log)){
			condsPerFault.put(log.getName, newArrayList)
			importsPerFault.put(log.getName, newArrayList)
			var logFaultCond = faultCondsMap.get(log.faultCond);
			syncpointsInitialRequest.put(logFaultCond.name, newArrayList)
			logsMap.put(log.name, log)
			//log.faultCond.extraData = combineCodeBoxes(log.faultCond.extraData, log.extraData)
		}
	}
	
	//if i compile several faults in row they overlap eachother, so each run they are all deleted
	def clearLists() {
		codeBlocksMap.clear
		condsMap.clear
		faultCondsMap.clear
		syncpointsMap.clear
		execParamsMap.clear
		faultsCompiled.clear
		logsCompiled.clear
		syncpointsInitialRequest.clear
		faultCondPerFault.clear
		importsPerFault.clear
		condsPerFault.clear
	}
	
	def proteusRuntimeJunction(String firstAttachPoint) {
		'''
		@Before("«firstAttachPoint»")
			public void proteusRuntimeJunction(JoinPoint joinpoint) {
		        try {
		            ProteusRuntime.makeInitialConnection(curNodeName, nodeLocation, coordinatorLocation, faulty, syncpointsDepend, syncpointsTrigger); //runtime start and initial request
		        } catch (Exception e) {
		            e.printStackTrace();
		        }
			}
		'''

	}
	
	def makeHeader(String runtimePackage, ArrayList<String> extraImports, String coordinatorLocation, String nodeLocation, String nodeName, Boolean faulty, ArrayList<String> nodeSyncPointsInitialRequestDependant, ArrayList<String> nodeSyncpointsInitialRequestTrigger) {
		'''
		«runtimePackage»
		import org.aspectj.lang.JoinPoint;
		import org.aspectj.lang.ProceedingJoinPoint;
		import org.aspectj.lang.annotation.Before;
		import org.aspectj.lang.annotation.AfterReturning;
		import org.aspectj.lang.annotation.Around;
		import org.aspectj.lang.annotation.Aspect;
		import java.security.SecureRandom;
		
		import client.runtime.ProteusRuntime;
		«FOR imports: extraImports SEPARATOR '\n'»
			«imports»
		«ENDFOR»
		«IF importsPerFault.get(nodeName) !== null && !importsPerFault.get(nodeName).isEmpty()»
			«importsPerFault.get(nodeName)»
		«ENDIF»
		@Aspect
		public class «nodeName + 'gen'» {
			protected static SecureRandom randomGen = new SecureRandom();
			String coordinatorLocation = "«coordinatorLocation»";
			String nodeLocation = "«nodeLocation»";
			String curNodeName = "«nodeName»";
			Boolean faulty = «faulty»;
			String randomLogData = "";
			String[] syncpointsDepend = {
		«FOR syncs: nodeSyncPointsInitialRequestDependant SEPARATOR ','»
			"«syncs»","«syncpointsMap.get(syncs).faultCond.name»","«syncpointsMap.get(syncs).type.literal»"
		«ENDFOR»
			};
			String[] syncpointsTrigger = {
		«FOR syncs: nodeSyncpointsInitialRequestTrigger SEPARATOR ','»
			"«syncs»","«syncpointsMap.get(syncs).faultCond.name»","«syncpointsMap.get(syncs).type.literal»"
		«ENDFOR»
			};
		'''
	}
	
	String preMadeFaults =
		'''
		import java.security.SecureRandom;
		import java.util.ArrayList;
		import java.util.List;

		public class PreMadeFaults{

		  protected static SecureRandom randomGen = null;
		  static {
		      randomGen = new SecureRandom();
		  }

		  public byte[] static bigPacketFault(Object data, Integer timesLarger) {
			byte[] dataBytes = (byte[]) data;
		    Integer lenghtD = dataBytes.length * timesLarger;
		    Integer iterator = dataBytes.length;
		    byte[] dataR = new byte[lenghtD];
		    for(int i=0; i<lenghtD; i=i+iterator) {
		      System.arraycopy(data, 0, dataR, i, data.length);
		    }
		    return dataR;
		  }

		  public byte[] static alterPacketFault(Object data, String kind) {
			byte[] dataBytes = (byte[]) data;
		    Integer testR;
		    if(kind.equals("random")){
		      for (int i = 0; i < dataBytes.length; i++) {
		        testR = randomGen.nextInt(126);
		        dataBytes[i] = testR.byteValue();
		      }
		    } else {
		      for (int i = 0; i < dataBytes.length; i++) {
		    	  dataBytes[i] = 0;
		      }
		    }
		    return dataBytes;
		  }

		  public void static stackLeakFault(Integer numberOfLeaks) {
		    Integer leakSize = 1024 * 1024 * 30; //small leaks 30mbytes
		    List<byte[]> leakList = new ArrayList<>();
		    byte[] leak = new byte[leakSize];
		    for(int i = 0; i<numberOfLeaks; i++) {
		      randomGen.nextBytes(leak);
		      leakList.add(leak);
		    }
		    long allocatedMemory = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory());
		    long presumableFreeMemory = Runtime.getRuntime().maxMemory() - allocatedMemory;
		    System.out.println("Memory left " + presumableFreeMemory);
		    leakList.clear();
		  }
		  
		    class threadLoad implements Runnable{
		  	@Override
		  	public void run(){  //needed for fault load, just throw anything to make some cpu waste
		  		while(true) {
		  			Integer wasting = 2;
		  			Integer twaste = 1024*1024*1024;
		  			while(wasting<twaste) {
		  				wasting = wasting * 2;
		  			}
		  		}
		  	}
		    }

		}

		'''
}
