/*
 * generated by Xtext 2.24.0
 */
package org.xtext.generator

import java.util.HashMap
import java.util.Iterator
import java.util.Map.Entry
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.agen.AlterPacketFault
import org.xtext.agen.BigPacketFault
import org.xtext.agen.RepeatExecution
import org.xtext.agen.CodeBlock
import org.xtext.agen.Condition
import org.xtext.agen.ExecParams
import org.xtext.agen.Exit
import org.xtext.agen.Fault
import org.xtext.agen.FaultCond
import org.xtext.agen.LeakFault
import org.xtext.agen.Log
import org.xtext.agen.Node
import org.xtext.agen.Random
import org.xtext.agen.RunConfiguration
import org.xtext.agen.Sleep
import org.xtext.agen.Syncpoint
import org.xtext.agen.What
import org.xtext.agen.When
import org.xtext.agen.Where
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AgenGenerator extends AbstractGenerator {

	HashMap<String, String> codeBlocksMap = newHashMap();
	HashMap<String, String> condsMap = newHashMap();
	HashMap<String, FaultCond> faultCondsMap = newHashMap();
	HashMap<String, Syncpoint> syncpointsMap = newHashMap();
	HashMap<String, ExecParams> execParamsMap = newHashMap();
	HashMap<String, String> faultsCompiled = newHashMap();
	//firstvalue is the header second is the compiled faultCond
	HashMap<String, Pair<String,String>> logsCompiled = newHashMap();
	//a fault e a lista de syncpoints que depende
	HashMap<String, ArrayList<String>> syncpointsInitialRequest = newHashMap();
	HashMap<String, ArrayList<String>> faultCondPerFault = newHashMap();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		clearLists()
		getLists(resource)
		compileFaults(resource)
		for(runConfig : resource.allContents.toIterable.filter(RunConfiguration)){
			runConfig.compile(fsa)
			//the object types extends EObject so i have access to its methods
		}
		fsa.generateFile(
			"helper.java", preMadeFaults
		)
	}
	
	def compile(RunConfiguration runConfig, IFileSystemAccess2 fsa){
		for (node : runConfig.nodes){
			fsa.generateFile(
				node.name + 'gen.java', node.compile(runConfig.coordinatorLocation)
			)
		}
	}
	
	def compile(Node node, String coordinatorLocation) {
		if(node.faultIDs.get(0) == 'none'){
			return
			'''
			«makeHeader(coordinatorLocation, node.nodeLocation, node.name, false, newArrayList, newArrayList)»
			«makeLogHeader(node.logLocations)»
			«zermiaRuntimeJunction(node.firstAttachPoint)»
			«makeLogConditions(node.logLocations)»
			'''
		} else {
			var nodeSyncpointsInitialRequestDepend = newArrayList
			var nodeSyncpointsInitialRequestTrigger = newArrayList
			var nodeFaultConditions = newArrayList
			var ret =
			'''
			«makeLogHeader(node.logLocations)»
			«zermiaRuntimeJunction(node.firstAttachPoint)»
			
			«IF node.faultIDs.get(0) == 'all'»
				«FOR faults : faultsCompiled.entrySet SEPARATOR '\n'»
					«var discard = nodeSyncpointsInitialRequestDepend.addAll(syncpointsInitialRequest.get(faults.key))»
					«faults.value»
					«var discard2 = nodeFaultConditions.addAll(faultCondPerFault.get(faults.key))»
				«ENDFOR»
			«ELSE»
				«FOR faultID : node.faultIDs»
					«var discard = nodeSyncpointsInitialRequestDepend.addAll(syncpointsInitialRequest.get(faultID))»
					«faultsCompiled.get(faultID)»
					«var discard2 = nodeFaultConditions.addAll(faultCondPerFault.get(faultID))»
					
				«ENDFOR»
			«ENDIF»
			«makeSyncpointsFaultCond(node.name, nodeSyncpointsInitialRequestTrigger, nodeFaultConditions)»
			«makeFaultCond(nodeFaultConditions)»
			«makeLogConditions(node.logLocations)»
			«makeCondFuncs»
			}
			'''
			ret = makeHeader(coordinatorLocation, node.nodeLocation, node.name, true, nodeSyncpointsInitialRequestDepend, nodeSyncpointsInitialRequestTrigger) + ret
			return ret
		}
	}
		
	def makeFaultCond(ArrayList<String> nodeFaultConditions) {
		var ret = ""
		for (faultCondName : nodeFaultConditions) {
			ret += faultCondsMap.get(faultCondName).compile("")
		}
		return ret
	}
		
	def String makeSyncpointsFaultCond(String nodeName, ArrayList<String> nodeSyncpointsInitialRequestTrigger, ArrayList<String> nodeFaultConditions) {
		var ret = ''
		for (syncs : syncpointsMap.values){
			for ( syncsDependants : syncs.nodesDependant ){
				if (syncsDependants.equals(nodeName)) {
					nodeFaultConditions.add(syncs.faultCond.name)
					nodeSyncpointsInitialRequestTrigger.add(syncs.name)
				}
			}
		}
		return ret
	}
		
	def String makeLogConditions(EList<String> list) {
		var ret=''
		for (logName : list){
			if (logName === null) return ret
			else {
				var vals = logsCompiled.get(logName)
				return ret.concat(vals.getValue())
			}
		}
	}
		
	def String makeLogHeader(EList<String> list) {
		var ret=''
		for (logName : list){
			if (logName === null) return ret
			else {
				var vals = logsCompiled.get(logName)
				return ret.concat(vals.getKey())
			}
		}
	}
	
	def compileFaults(Resource resource) {
		//iterate over the faultConds to add them after the fault
		for(fault : resource.allContents.toIterable.filter(Fault)){
			syncpointsInitialRequest.put(fault.name, newArrayList)
			faultCondPerFault.put(fault.name, newArrayList)
			var result=''
			result += fault.compile + '\n'
			faultsCompiled.put(fault.name, result)
		}
	}

		private def compile(Fault fault)
		'''
		«FOR ExecParams exec : fault.execParams»
			«IF exec.when !== null && exec.when.betweenRounds !== null»
				int «exec.getName»counter = 0;
			«ENDIF»
		«ENDFOR»
		@Around(execution («fault.pointcut»))
		public void «fault.name»(ProceedingJoinPoint joinPoint){
			Object retobj = null;
			String randomLogData = "";
			long startTimestamp = System.currentTimeMillis();
			Object[] args = joinPoint.getArgs();
			«execCompileConditions(fault.execParams, 'Before', fault.name)»
			retobj = joinpoint.proceed(arg);
			«execCompileConditions(fault.execParams, 'After', fault.name)»
			ZermiaRuntime.sendLogs(curNodeName, "«fault.name»", startTimestamp, randomLogData);
			return retobj;
		}
		'''
		
	def String execCompileConditions(EList <ExecParams> execParamsList, String BeforeAfter, String faultName) {
		var result = ''
		for (ExecParams exec : execParamsList){
			var realExecParams = execParamsMap.get(exec.getName)
			if (realExecParams.where.literal == BeforeAfter)
				result += realExecParams.compile(faultName)
		}
		return result
	}
		
	private def compile (ExecParams exec, String faultName)
	'''
	«IF exec.when !== null»
		«exec.when.compile(exec.what.compile(faultName).toString, exec.getName, faultName)»
	«ELSE»
		«exec.what.compile(faultName)»
	«ENDIF»
	'''

	private def compile (When when, String whatToExecute, String execParamsName, String faultName)
	'''
	«IF when.betweenRounds !== null»
		«makeBetweenIf(when.betweenRounds.start, when.betweenRounds.end, when.betweenRounds.interval , execParamsName + "counter")»
		«IF when.betweenRounds.random !== null»
			«when.betweenRounds.random.compile»
			ZermiaRuntime.addLogExecInfo(«execParamsName», Round, String.valueOf(«execParamsName»counter);
			«whatToExecute» }}
		«ELSE»
			ZermiaRuntime.addLogExecInfo(«execParamsName», Round, String.valueOf(«execParamsName»counter);
			«whatToExecute» }
		«ENDIF»
		«IF when.betweenRounds.condition!==null»
			if( «when.betweenRounds.condition.name»(retobj, joinpoint))
				«execParamsName»counter++;
		«ELSE»
			«execParamsName»counter++;
		«ENDIF»
	«ELSEIF when.ifCondition !== null»
		if(«when.ifCondition.getName»(retobj, joinpoint)){
		ZermiaRuntime.addLogExecInfo(«execParamsName», Custom, "true");
		«whatToExecute» }
	«ELSEIF when.random !== null»
		«when.random.compile»
		ZermiaRuntime.addLogExecInfo(«execParamsName», Random, "true");
		«whatToExecute» }
	«ELSEIF when.faultCond !== null»
		«faultCondPerFault.get(faultName).add(when.faultCond.name)»
		ZermiaRuntime.addLogExecInfo(«execParamsName», FaultCond, "true");
		«makeFaultCondIf(when.faultCond, whatToExecute)»
	«ELSEIF when.syncpoint!==null»
		«var syncpointOnFail = syncpointsMap.get(when.syncpoint).onFail.literal»
		«syncpointsInitialRequest.get(faultName).add(when.syncpoint)»
		«IF syncpointOnFail.equals('continue')»
			if(ZermiaRuntime.askSyncpointStatus(curNodeName, «when.syncpoint»)){
				ZermiaRuntime.addLogExecInfo(«execParamsName», Sync, "true");
				«whatToExecute»
			}
		«ELSEIF syncpointOnFail.equals('retry')»
			while(!ZermiaRuntime.askSyncpointStatus(curNodeName, «when.syncpoint»)){ Thread.sleep(1000); }
			ZermiaRuntime.addLogExecInfo(«execParamsName», Sync, "«when.syncpoint»");
			«whatToExecute»
			}
		«ENDIF»
	«ENDIF»
	'''

	def compile (Random random)
	'''
	Integer randVal = randomGen.nextInt(100);
	if(randVal>«random.chance») {
	'''

	def String makeBetweenIf(int start, int end, int interval, String varname) {
		var String result = 'if('
		if(start != 0){
			result += varname + ' >= ' + start + ' && '
		}
		if(end != 0){
			result += varname + ' <= ' + end + ' && '
		}
		if(interval==0){
			return result + 'true){'
		}
		result += varname + ' % ' + interval + ' == 0){'
		return result;
	}

	def String makeFaultCondIf(FaultCond fcond, String whatToExecute) {
		var realfcond = fcond;
		//if its just a reference get the fully detailed one
		if (realfcond.where === null){
			realfcond = faultCondsMap.get(realfcond.name)
		}
		if (realfcond.when.betweenRounds !== null && realfcond.when.betweenRounds.interval != 0){
			return 'if( ' + realfcond.getName + '){' + whatToExecute + '}'
		}
		if (realfcond.when.betweenSeconds !== null){
			return 'if( ' + realfcond.getName + '){' + whatToExecute + '}'
		}
		return 'if( ' + realfcond.getName + '){' + whatToExecute + '\n' + realfcond.getName + '= false}'
	}

	private def compile(FaultCond fcond, String additionalLogData){
		//in case the fcond is just a name get the real one
		var realfcond = faultCondsMap.get(fcond.name)
		syncpointsInitialRequest.put(fcond.name, newArrayList)
		var whatToExecute = combineCodeBoxWithStrings(realfcond.extraData, realfcond.name + ' = true', additionalLogData)
		var ret = 
		'''
		
		Boolean «realfcond.name» = false
		«IF realfcond.when !== null && realfcond.when.betweenRounds !== null»
			int «realfcond.name»counter = 0;
		«ENDIF»
		«realfcond.where.compile(realfcond.name)»
			String randomLogData = "";
			long startTimestamp = System.currentTimeMillis();
			«realfcond.name» = false
			«IF realfcond.when !== null»
			«realfcond.when.compile(whatToExecute, realfcond.name, realfcond.name)»
			«ENDIF»
			ZermiaRuntime.sendLogs(curNodeName, "«fcond.name»", startTimestamp, randomLogData);
		}

		'''
	return ret
	}

	def compile(Where where, String name) {
		//if its not equal to before than its after returning
		'''
		«IF where.joinType.literal == "Before"»
		@Before(«where.getName»)
		public void «where.joinType.literal»«name»(JoinPoint joinPoint) {
			Object retval = null;
			Object[] args = joinPoint.getArgs();
		«ELSE»
		@AfterReturning( pointcut = «where.getName», returning = "retval")
		public void «where.joinType.literal»«name»(JoinPoint joinpoint, Object retobj) {
			Object[] args = joinPoint.getArgs();
		«ENDIF»
	'''
	}

	def String makeCondFuncs(){

		var result = ''
		var Iterator<Entry<String, String>> condsIt = condsMap.entrySet().iterator();
		while (condsIt.hasNext()){
			var Entry<String, String> pair = condsIt.next() as Entry<String, String>;
			result += '''
			private Boolean «pair.getKey()» (Object retval, JoinPoint joinPoint){
				«pair.getValue()»
			}
			'''
		}
		result
	}

	private def compile(What what, String faultName)
	'''
	«IF what.codeBlock !== null»
		«what.codeBlock.compile»
	«ELSEIF what.sleep !== null»
		«what.sleep.compile»
	«ELSEIF what.exit !== null»
		«what.exit.compile(faultName)»
	«ELSEIF what.bigPacketFault !== null»
		«what.bigPacketFault.compile»
	«ELSEIF what.leakFault !== null»
		«what.leakFault.compile»
	«ELSEIF what.alterPacketFault !== null»
		«what.alterPacketFault.compile»
	«ELSEIF what.skipExecution !== null»
		«skipExecutionCompile(faultName)»
	«ELSEIF what.repeatExecution !== null»
		«what.repeatExecution.compile»
	«ENDIF»
	'''
	
	private def compile(RepeatExecution repeatExecution)
	'''
		for(int i=0;i<«repeatExecution.times»;i++){
			joinpoint.proceed(args);
		}
	'''
		
	def skipExecutionCompile(String faultName) {
		'''
		ZermiaRuntime.sendLogs(curNodeName, "«faultName»", startTimestamp, randomLogData);
		return;
		'''
	}
	
	private def compile(Sleep sleep)
	'''
		Thread.sleep(«sleep.time»);
	'''

	private def compile(Exit exit, String faultName)
	'''
		ZermiaRuntime.sendLogs(curNodeName, "«faultName»", startTimestamp, randomLogData);
		System.exit(«exit.type»);
	'''

	private def compile(BigPacketFault bpf)
	'''
		premade.bigpacketFault(args[«bpf.originalData»], «bpf.timesLarger»);
	'''

	private def compile(LeakFault lf)
	'''
		premade.leakFault(«lf.nrofLeaks»);
	'''

	private def compile(AlterPacketFault apf)
	'''
		premade.alterPacketFault(args[«apf.originalData»], «apf.kindOfAlteration.literal»);
	'''

	private def compile(CodeBlock cb){
		return codeBlocksMap.get(cb.getName);
	}
		
	def CodeBlock combineCodeBoxes(CodeBlock first, CodeBlock second){
		if (first===null) {
			return second
		} else if(second === null){
			return first
		} else {
		//puts the second into the first one and returns it
		var firstCodeBlock = first.compile.toString()
		var secondCodeBlock = second.compile.toString()
		first.code = firstCodeBlock.concat(secondCodeBlock)
		first.name = null
		return first
		}
	}
	
	def String combineCodeBoxWithStrings(CodeBlock block, String string1, String string2) {
		var string = string1 + string2
		if (block === null){
			return string
		} else {
			return block.compile.toString + string
		}
	}
	
	//returns the hashmaps for the CodeBlocks, Conditions and FaultConditions
	//populates the name field when needed
	def getLists(Resource resource) {
		var counter=0
		
		for(block : resource.allContents.toIterable.filter(CodeBlock)){
			if (block.getName === null){
				block.setName("codeBlock"+counter);
				counter ++;
			}
			codeBlocksMap.put(block.getName, block.code);
		}
		
        counter=0
		for(condition : resource.allContents.toIterable.filter(Condition)){
			if (condition.getName === null){
				condition.setName("cond"+counter)
				counter++
			}
			condsMap.put(condition.getName, condition.code);
		}

		counter = 0
		for(faultCondition : resource.allContents.toIterable.filter(FaultCond)){
			//if its not just a reference to a faultcondition add it to the hashmap
			if (faultCondition.where !== null){
				if (faultCondition.getName === null){
					faultCondition.setName('fCond' + counter)
					counter++
				}
				faultCondsMap.put(faultCondition.getName, faultCondition);
			}
		}
		
		counter = 0
		for(exec : resource.allContents.toIterable.filter(ExecParams)){
			if (exec.getName === null){
				exec.setName('execParam'+counter)
				counter++
			}
			execParamsMap.put(exec.getName, exec);
		}
		
		for(syncs : resource.allContents.toIterable.filter(Syncpoint)){
			syncpointsMap.put(syncs.name, syncs)
		}
		
		for(log : resource.allContents.toIterable.filter(Log)){
			//log.faultCond.extraData = combineCodeBoxes(log.faultCond.extraData, log.extraData)
			var stateBased = ""
			var extraData = ""
			if (log.stateBased!==null) {
				stateBased = log.stateBased.compile	
			}
			if (log.extraData!==null) {
				extraData = log.extraData.compile
			}
			var logFaultCond = faultCondsMap.get(log.faultCond);
			logsCompiled.put(log.name, new Pair(stateBased, logFaultCond.compile(extraData)))
		}
	}
	
	//if i compile several faults in row they overlap eachother, so each run they are all deleted
	def clearLists() {
		codeBlocksMap.clear
		condsMap.clear
		faultCondsMap.clear
		syncpointsMap.clear
		execParamsMap.clear
		faultsCompiled.clear
		logsCompiled.clear
		syncpointsInitialRequest.clear
		faultCondPerFault.clear
	}
	
	def zermiaRuntimeJunction(String firstAttachPoint) {
		'''
		@Before("execution (* «firstAttachPoint»*(..))")
			public void zermiaRuntimeJunction(JoinPoint joinPoint) {
		        try {
		            ZermiaRuntime.makeInitialConnection(curNodeName, nodeLocation, coordinatorLocation, faulty, syncpointsDepend, syncpointsTrigger); //runtime start and initial request
		        } catch (Exception e) {
		            e.printStackTrace();
		        }
			}
		'''

	}
	
	def makeHeader(String coordinatorLocation, String nodeLocation, String nodeName, Boolean faulty, ArrayList<String> nodeSyncPointsInitialRequestDependant, ArrayList<String> nodeSyncpointsInitialRequestTrigger) {
		'''
		import org.aspectj.lang.JoinPoint;
		import org.aspectj.lang.ProceedingJoinPoint;
		import org.aspectj.lang.annotation.Before;
		import org.aspectj.lang.annotation.AfterReturning;
		import org.aspectj.lang.annotation.Around;
		import org.aspectj.lang.annotation.Aspect;
		import java.security.SecureRandom;
		
		import proteus.runtime.proteusRuntime;
		
		@Aspect
		public class AgentInstance {
			preMadeFaults premade = new PreMadeFaults;
			sharedFuncs sharedFuncs = new SharedFuncs;
			randomGen = new SecureRandom();
			String coordinatorLocation = "«coordinatorLocation»";
			String nodeLocation = "«nodeLocation»";
			String curNodeName = "«nodeName»";
			Boolean faulty = «faulty»;
			String randomLogData = "";
			String[] syncpointsDepend = {
		«FOR syncs: nodeSyncPointsInitialRequestDependant SEPARATOR ','»
			"«syncs»","«syncpointsMap.get(syncs).faultCond.name»","«syncpointsMap.get(syncs).type.literal»"
		«ENDFOR»
			};
			String[] syncpointsTrigger = {
		«FOR syncs: nodeSyncpointsInitialRequestTrigger SEPARATOR ','»
			"«syncs»","«syncpointsMap.get(syncs).faultCond.name»","«syncpointsMap.get(syncs).type.literal»"
		«ENDFOR»
			};
		'''
	}
	
	String preMadeFaults =
		'''
		import java.security.SecureRandom;
		import java.util.ArrayList;
		import java.util.List;

		public class PreMadeFaults{

		  protected static SecureRandom randomGen = null;
		  static {
		      randomGen = new SecureRandom();
		  }

		  public byte[] bigPacketFault(byte[] data, Integer timesLarger) {
		    Integer lenghtD = data.length * timesLarger;
		    Integer iterator = data.length;
		    byte[] dataR = new byte[lenghtD];
		    for(int i=0; i<lenghtD; i=i+iterator) {
		      System.arraycopy(data, 0, dataR, i, data.length);
		    }
		    return dataR;
		  }

		  public byte[] alterPacketFault(byte[] data, String kind) {
		    Integer testR;
		    if(kind.equals('random')){
		      for (int i = 0; i < data.length; i++) {
		        testR = randomGen.nextInt(126);
		        data[i] = testR.byteValue();
		      }
		    } else {
		      for (int i = 0; i < data.length; i++) {
		        data[i] = 0;
		      }
		    }
		    return data;
		  }

		  public void stackLeakFault(Integer numberOfLeaks) {
		    Integer leakSize = 1024 * 1024 * 30; //small leaks 30mbytes
		    List<byte[]> leakList = new ArrayList<>();
		    byte[] leak = new byte[leakSize];
		    for(int i = 0; i<numberOfLeaks; i++) {
		      randomGen.nextBytes(leak);
		      leakList.add(leak);
		    }
		    long allocatedMemory = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory());
		    long presumableFreeMemory = Runtime.getRuntime().maxMemory() - allocatedMemory;
		    System.out.println("Memory left " + presumableFreeMemory);

		    leakList.clear();
		  }

		}

		'''
}
